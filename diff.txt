diff --git a/cdx/models/docs.py b/cdx/models/docs.py
index af095ac..2b9edd4 100644
--- a/cdx/models/docs.py
+++ b/cdx/models/docs.py
@@ -64,13 +64,14 @@ def find_refs_list(datalist, refs=None):
         find_refs_json(v, refs=refs)
             
                 
-def new_doc(flaskapp, docid, title, rw_users=None, r_users=None):
+def new_doc(flaskapp, docid, title, rw_users=None, r_users=None, apikey=None):
+    if not apikey: apikey = str(uuid.uuid4())
     plot_context = bbmodel.ContinuumModel(
         'CDXPlotContext', docs=[docid])
     flaskapp.collections.add(plot_context)
     if rw_users is None: rw_users = []
     if r_users is None: r_users = []
-    doc = Doc(docid, title, rw_users, r_users, plot_context.ref(), str(uuid.uuid4()))
+    doc = Doc(docid, title, rw_users, r_users, plot_context.ref(), apikey)
     doc.save(flaskapp.model_redis)
     return doc
 
diff --git a/cdx/redis.conf b/cdx/redis.conf
new file mode 100644
index 0000000..b4338df
--- /dev/null
+++ b/cdx/redis.conf
@@ -0,0 +1,489 @@
+# Redis configuration file example
+
+# Note on units: when memory size is needed, it is possible to specifiy
+# it in the usual form of 1k 5GB 4M and so forth:
+#
+# 1k => 1000 bytes
+# 1kb => 1024 bytes
+# 1m => 1000000 bytes
+# 1mb => 1024*1024 bytes
+# 1g => 1000000000 bytes
+# 1gb => 1024*1024*1024 bytes
+#
+# units are case insensitive so 1GB 1Gb 1gB are all the same.
+
+# By default Redis does not run as a daemon. Use 'yes' if you need it.
+# Note that Redis will write a pid file in /var/run/redis.pid when daemonized.
+daemonize no
+
+# When running daemonized, Redis writes a pid file in /var/run/redis.pid by
+# default. You can specify a custom pid file location here.
+pidfile /var/run/redis.pid
+
+# Accept connections on the specified port, default is 6379.
+# If port 0 is specified Redis will not listen on a TCP socket.
+port %(port)d
+
+# If you want you can bind a single interface, if the bind option is not
+# specified all the interfaces will listen for incoming connections.
+#
+# bind 127.0.0.1
+
+# Specify the path for the unix socket that will be used to listen for
+# incoming connections. There is no default, so Redis will not listen
+# on a unix socket when not specified.
+#
+# unixsocket /tmp/redis.sock
+# unixsocketperm 755
+
+# Close the connection after a client is idle for N seconds (0 to disable)
+timeout 0
+
+# Set server verbosity to 'debug'
+# it can be one of:
+# debug (a lot of information, useful for development/testing)
+# verbose (many rarely useful info, but not a mess like the debug level)
+# notice (moderately verbose, what you want in production probably)
+# warning (only very important / critical messages are logged)
+loglevel verbose
+
+# Specify the log file name. Also 'stdout' can be used to force
+# Redis to log on the standard output. Note that if you use standard
+# output for logging but daemonize, logs will be sent to /dev/null
+logfile stdout
+
+# To enable logging to the system logger, just set 'syslog-enabled' to yes,
+# and optionally update the other syslog parameters to suit your needs.
+# syslog-enabled no
+
+# Specify the syslog identity.
+# syslog-ident redis
+
+# Specify the syslog facility.  Must be USER or between LOCAL0-LOCAL7.
+# syslog-facility local0
+
+# Set the number of databases. The default database is DB 0, you can select
+# a different one on a per-connection basis using SELECT <dbid> where
+# dbid is a number between 0 and 'databases'-1
+databases 16
+
+################################ SNAPSHOTTING  #################################
+#
+# Save the DB on disk:
+#
+#   save <seconds> <changes>
+#
+#   Will save the DB if both the given number of seconds and the given
+#   number of write operations against the DB occurred.
+#
+#   In the example below the behaviour will be to save:
+#   after 900 sec (15 min) if at least 1 key changed
+#   after 300 sec (5 min) if at least 10 keys changed
+#   after 60 sec if at least 10000 keys changed
+#
+#   Note: you can disable saving at all commenting all the "save" lines.
+
+# save 900 1
+# save 300 10
+# save 60 10000
+%(save)s
+
+# Compress string objects using LZF when dump .rdb databases?
+# For default that's set to 'yes' as it's almost always a win.
+# If you want to save some CPU in the saving child set it to 'no' but
+# the dataset will likely be bigger if you have compressible values or keys.
+rdbcompression yes
+
+# The filename where to dump the DB
+dbfilename %(dbfile)s
+
+# The working directory.
+#
+# The DB will be written inside this directory, with the filename specified
+# above using the 'dbfilename' configuration directive.
+# 
+# Also the Append Only File will be created inside this directory.
+# 
+# Note that you must specify a directory here, not a file name.
+dir %(dbdir)s
+
+################################# REPLICATION #################################
+
+# Master-Slave replication. Use slaveof to make a Redis instance a copy of
+# another Redis server. Note that the configuration is local to the slave
+# so for example it is possible to configure the slave to save the DB with a
+# different interval, or to listen to another port, and so on.
+#
+# slaveof <masterip> <masterport>
+
+# If the master is password protected (using the "requirepass" configuration
+# directive below) it is possible to tell the slave to authenticate before
+# starting the replication synchronization process, otherwise the master will
+# refuse the slave request.
+#
+# masterauth <master-password>
+
+# When a slave lost the connection with the master, or when the replication
+# is still in progress, the slave can act in two different ways:
+#
+# 1) if slave-serve-stale-data is set to 'yes' (the default) the slave will
+#    still reply to client requests, possibly with out of data data, or the
+#    data set may just be empty if this is the first synchronization.
+#
+# 2) if slave-serve-stale data is set to 'no' the slave will reply with
+#    an error "SYNC with master in progress" to all the kind of commands
+#    but to INFO and SLAVEOF.
+#
+slave-serve-stale-data yes
+
+# Slaves send PINGs to server in a predefined interval. It's possible to change
+# this interval with the repl_ping_slave_period option. The default value is 10
+# seconds.
+#
+# repl-ping-slave-period 10
+
+# The following option sets a timeout for both Bulk transfer I/O timeout and
+# master data or ping response timeout. The default value is 60 seconds.
+#
+# It is important to make sure that this value is greater than the value
+# specified for repl-ping-slave-period otherwise a timeout will be detected
+# every time there is low traffic between the master and the slave.
+#
+# repl-timeout 60
+
+################################## SECURITY ###################################
+
+# Require clients to issue AUTH <PASSWORD> before processing any other
+# commands.  This might be useful in environments in which you do not trust
+# others with access to the host running redis-server.
+#
+# This should stay commented out for backward compatibility and because most
+# people do not need auth (e.g. they run their own servers).
+# 
+# Warning: since Redis is pretty fast an outside user can try up to
+# 150k passwords per second against a good box. This means that you should
+# use a very strong password otherwise it will be very easy to break.
+#
+# requirepass foobared
+
+# Command renaming.
+#
+# It is possilbe to change the name of dangerous commands in a shared
+# environment. For instance the CONFIG command may be renamed into something
+# of hard to guess so that it will be still available for internal-use
+# tools but not available for general clients.
+#
+# Example:
+#
+# rename-command CONFIG b840fc02d524045429941cc15f59e41cb7be6c52
+#
+# It is also possilbe to completely kill a command renaming it into
+# an empty string:
+#
+# rename-command CONFIG ""
+
+################################### LIMITS ####################################
+
+# Set the max number of connected clients at the same time. By default there
+# is no limit, and it's up to the number of file descriptors the Redis process
+# is able to open. The special value '0' means no limits.
+# Once the limit is reached Redis will close all the new connections sending
+# an error 'max number of clients reached'.
+#
+# maxclients 128
+
+# Don't use more memory than the specified amount of bytes.
+# When the memory limit is reached Redis will try to remove keys
+# accordingly to the eviction policy selected (see maxmemmory-policy).
+#
+# If Redis can't remove keys according to the policy, or if the policy is
+# set to 'noeviction', Redis will start to reply with errors to commands
+# that would use more memory, like SET, LPUSH, and so on, and will continue
+# to reply to read-only commands like GET.
+#
+# This option is usually useful when using Redis as an LRU cache, or to set
+# an hard memory limit for an instance (using the 'noeviction' policy).
+#
+# WARNING: If you have slaves attached to an instance with maxmemory on,
+# the size of the output buffers needed to feed the slaves are subtracted
+# from the used memory count, so that network problems / resyncs will
+# not trigger a loop where keys are evicted, and in turn the output
+# buffer of slaves is full with DELs of keys evicted triggering the deletion
+# of more keys, and so forth until the database is completely emptied.
+#
+# In short... if you have slaves attached it is suggested that you set a lower
+# limit for maxmemory so that there is some free RAM on the system for slave
+# output buffers (but this is not needed if the policy is 'noeviction').
+#
+# maxmemory <bytes>
+
+# MAXMEMORY POLICY: how Redis will select what to remove when maxmemory
+# is reached? You can select among five behavior:
+# 
+# volatile-lru -> remove the key with an expire set using an LRU algorithm
+# allkeys-lru -> remove any key accordingly to the LRU algorithm
+# volatile-random -> remove a random key with an expire set
+# allkeys->random -> remove a random key, any key
+# volatile-ttl -> remove the key with the nearest expire time (minor TTL)
+# noeviction -> don't expire at all, just return an error on write operations
+# 
+# Note: with all the kind of policies, Redis will return an error on write
+#       operations, when there are not suitable keys for eviction.
+#
+#       At the date of writing this commands are: set setnx setex append
+#       incr decr rpush lpush rpushx lpushx linsert lset rpoplpush sadd
+#       sinter sinterstore sunion sunionstore sdiff sdiffstore zadd zincrby
+#       zunionstore zinterstore hset hsetnx hmset hincrby incrby decrby
+#       getset mset msetnx exec sort
+#
+# The default is:
+#
+# maxmemory-policy volatile-lru
+
+# LRU and minimal TTL algorithms are not precise algorithms but approximated
+# algorithms (in order to save memory), so you can select as well the sample
+# size to check. For instance for default Redis will check three keys and
+# pick the one that was used less recently, you can change the sample size
+# using the following configuration directive.
+#
+# maxmemory-samples 3
+
+############################## APPEND ONLY MODE ###############################
+
+# By default Redis asynchronously dumps the dataset on disk. If you can live
+# with the idea that the latest records will be lost if something like a crash
+# happens this is the preferred way to run Redis. If instead you care a lot
+# about your data and don't want to that a single record can get lost you should
+# enable the append only mode: when this mode is enabled Redis will append
+# every write operation received in the file appendonly.aof. This file will
+# be read on startup in order to rebuild the full dataset in memory.
+#
+# Note that you can have both the async dumps and the append only file if you
+# like (you have to comment the "save" statements above to disable the dumps).
+# Still if append only mode is enabled Redis will load the data from the
+# log file at startup ignoring the dump.rdb file.
+#
+# IMPORTANT: Check the BGREWRITEAOF to check how to rewrite the append
+# log file in background when it gets too big.
+
+appendonly no
+
+# The name of the append only file (default: "appendonly.aof")
+# appendfilename appendonly.aof
+
+# The fsync() call tells the Operating System to actually write data on disk
+# instead to wait for more data in the output buffer. Some OS will really flush 
+# data on disk, some other OS will just try to do it ASAP.
+#
+# Redis supports three different modes:
+#
+# no: don't fsync, just let the OS flush the data when it wants. Faster.
+# always: fsync after every write to the append only log . Slow, Safest.
+# everysec: fsync only if one second passed since the last fsync. Compromise.
+#
+# The default is "everysec" that's usually the right compromise between
+# speed and data safety. It's up to you to understand if you can relax this to
+# "no" that will will let the operating system flush the output buffer when
+# it wants, for better performances (but if you can live with the idea of
+# some data loss consider the default persistence mode that's snapshotting),
+# or on the contrary, use "always" that's very slow but a bit safer than
+# everysec.
+#
+# If unsure, use "everysec".
+
+# appendfsync always
+appendfsync everysec
+# appendfsync no
+
+# When the AOF fsync policy is set to always or everysec, and a background
+# saving process (a background save or AOF log background rewriting) is
+# performing a lot of I/O against the disk, in some Linux configurations
+# Redis may block too long on the fsync() call. Note that there is no fix for
+# this currently, as even performing fsync in a different thread will block
+# our synchronous write(2) call.
+#
+# In order to mitigate this problem it's possible to use the following option
+# that will prevent fsync() from being called in the main process while a
+# BGSAVE or BGREWRITEAOF is in progress.
+#
+# This means that while another child is saving the durability of Redis is
+# the same as "appendfsync none", that in pratical terms means that it is
+# possible to lost up to 30 seconds of log in the worst scenario (with the
+# default Linux settings).
+# 
+# If you have latency problems turn this to "yes". Otherwise leave it as
+# "no" that is the safest pick from the point of view of durability.
+no-appendfsync-on-rewrite no
+
+# Automatic rewrite of the append only file.
+# Redis is able to automatically rewrite the log file implicitly calling
+# BGREWRITEAOF when the AOF log size will growth by the specified percentage.
+# 
+# This is how it works: Redis remembers the size of the AOF file after the
+# latest rewrite (or if no rewrite happened since the restart, the size of
+# the AOF at startup is used).
+#
+# This base size is compared to the current size. If the current size is
+# bigger than the specified percentage, the rewrite is triggered. Also
+# you need to specify a minimal size for the AOF file to be rewritten, this
+# is useful to avoid rewriting the AOF file even if the percentage increase
+# is reached but it is still pretty small.
+#
+# Specify a precentage of zero in order to disable the automatic AOF
+# rewrite feature.
+
+auto-aof-rewrite-percentage 100
+auto-aof-rewrite-min-size 64mb
+
+################################## SLOW LOG ###################################
+
+# The Redis Slow Log is a system to log queries that exceeded a specified
+# execution time. The execution time does not include the I/O operations
+# like talking with the client, sending the reply and so forth,
+# but just the time needed to actually execute the command (this is the only
+# stage of command execution where the thread is blocked and can not serve
+# other requests in the meantime).
+# 
+# You can configure the slow log with two parameters: one tells Redis
+# what is the execution time, in microseconds, to exceed in order for the
+# command to get logged, and the other parameter is the length of the
+# slow log. When a new command is logged the oldest one is removed from the
+# queue of logged commands.
+
+# The following time is expressed in microseconds, so 1000000 is equivalent
+# to one second. Note that a negative number disables the slow log, while
+# a value of zero forces the logging of every command.
+slowlog-log-slower-than 10000
+
+# There is no limit to this length. Just be aware that it will consume memory.
+# You can reclaim memory used by the slow log with SLOWLOG RESET.
+slowlog-max-len 128
+
+################################ VIRTUAL MEMORY ###############################
+
+### WARNING! Virtual Memory is deprecated in Redis 2.4
+### The use of Virtual Memory is strongly discouraged.
+
+# Virtual Memory allows Redis to work with datasets bigger than the actual
+# amount of RAM needed to hold the whole dataset in memory.
+# In order to do so very used keys are taken in memory while the other keys
+# are swapped into a swap file, similarly to what operating systems do
+# with memory pages.
+#
+# To enable VM just set 'vm-enabled' to yes, and set the following three
+# VM parameters accordingly to your needs.
+
+vm-enabled no
+# vm-enabled yes
+
+# This is the path of the Redis swap file. As you can guess, swap files
+# can't be shared by different Redis instances, so make sure to use a swap
+# file for every redis process you are running. Redis will complain if the
+# swap file is already in use.
+#
+# The best kind of storage for the Redis swap file (that's accessed at random) 
+# is a Solid State Disk (SSD).
+#
+# *** WARNING *** if you are using a shared hosting the default of putting
+# the swap file under /tmp is not secure. Create a dir with access granted
+# only to Redis user and configure Redis to create the swap file there.
+vm-swap-file /tmp/redis.swap
+
+# vm-max-memory configures the VM to use at max the specified amount of
+# RAM. Everything that deos not fit will be swapped on disk *if* possible, that
+# is, if there is still enough contiguous space in the swap file.
+#
+vm-max-memory 0
+
+# Redis swap files is split into pages. An object can be saved using multiple
+# contiguous pages, but pages can't be shared between different objects.
+# So if your page is too big, small objects swapped out on disk will waste
+# a lot of space. If you page is too small, there is less space in the swap
+# file (assuming you configured the same number of total swap file pages).
+#
+# If you use a lot of small objects, use a page size of 64 or 32 bytes.
+# If you use a lot of big objects, use a bigger page size.
+# If unsure, use the default :)
+vm-page-size 32
+
+# Number of total memory pages in the swap file.
+# Given that the page table (a bitmap of free/used pages) is taken in memory,
+# every 8 pages on disk will consume 1 byte of RAM.
+#
+# The total swap size is vm-page-size * vm-pages
+#
+# With the default of 32-bytes memory pages and 134217728 pages Redis will
+# use a 4 GB swap file, that will use 16 MB of RAM for the page table.
+#
+# It's better to use the smallest acceptable value for your application,
+# but the default is large in order to work in most conditions.
+vm-pages 134217728
+
+# Max number of VM I/O threads running at the same time.
+# This threads are used to read/write data from/to swap file, since they
+# also encode and decode objects from disk to memory or the reverse, a bigger
+# number of threads can help with big objects even if they can't help with
+# I/O itself as the physical device may not be able to couple with many
+# reads/writes operations at the same time.
+#
+# The special value of 0 turn off threaded I/O and enables the blocking
+# Virtual Memory implementation.
+vm-max-threads 4
+
+############################### ADVANCED CONFIG ###############################
+
+# Hashes are encoded in a special way (much more memory efficient) when they
+# have at max a given numer of elements, and the biggest element does not
+# exceed a given threshold. You can configure this limits with the following
+# configuration directives.
+hash-max-zipmap-entries 512
+hash-max-zipmap-value 64
+
+# Similarly to hashes, small lists are also encoded in a special way in order
+# to save a lot of space. The special representation is only used when
+# you are under the following limits:
+list-max-ziplist-entries 512
+list-max-ziplist-value 64
+
+# Sets have a special encoding in just one case: when a set is composed
+# of just strings that happens to be integers in radix 10 in the range
+# of 64 bit signed integers.
+# The following configuration setting sets the limit in the size of the
+# set in order to use this special memory saving encoding.
+set-max-intset-entries 512
+
+# Similarly to hashes and lists, sorted sets are also specially encoded in
+# order to save a lot of space. This encoding is only used when the length and
+# elements of a sorted set are below the following limits:
+zset-max-ziplist-entries 128
+zset-max-ziplist-value 64
+
+# Active rehashing uses 1 millisecond every 100 milliseconds of CPU time in
+# order to help rehashing the main Redis hash table (the one mapping top-level
+# keys to values). The hash table implementation redis uses (see dict.c)
+# performs a lazy rehashing: the more operation you run into an hash table
+# that is rhashing, the more rehashing "steps" are performed, so if the
+# server is idle the rehashing is never complete and some more memory is used
+# by the hash table.
+# 
+# The default is to use this millisecond 10 times every second in order to
+# active rehashing the main dictionaries, freeing memory when possible.
+#
+# If unsure:
+# use "activerehashing no" if you have hard latency requirements and it is
+# not a good thing in your environment that Redis can reply form time to time
+# to queries with 2 milliseconds delay.
+#
+# use "activerehashing yes" if you don't have such hard requirements but
+# want to free memory asap when possible.
+activerehashing yes
+
+################################## INCLUDES ###################################
+
+# Include one or more other config files here.  This is useful if you
+# have a standard template that goes to all redis server but also need
+# to customize a few per-server settings.  Include files can include
+# other files, so use this wisely.
+#
+# include /path/to/local.conf
+# include /path/to/other.conf
diff --git a/cdx/start.py b/cdx/start.py
index 91bcee4..c8cdd3d 100644
--- a/cdx/start.py
+++ b/cdx/start.py
@@ -1,3 +1,5 @@
+from geventwebsocket.handler import WebSocketHandler
+from gevent.pywsgi import WSGIServer
 from flask import request
 import gevent
 import gevent.monkey
@@ -31,10 +33,41 @@ def prepare_app(rhost='127.0.0.1', rport=6379):
     #for non-backbone models
     app.model_redis = redis.Redis(host=rhost, port=rport, db=3)
     app.secret_key = str(uuid.uuid4())
+
+def make_default_user(app):
+    docid = "defaultdoc"
+    doc = docs.new_doc(app, docid, 'main', ["defaultuser"], apikey='nokey')
+    cdxuser = user.new_user(app.model_redis, "defaultuser",
+                            str(uuid.uuid4()),
+                            docs=[doc.docid])
+    return cdxuser
+    
+def prepare_local():
+    app.debug = True
+    #monkeypatching
+    def current_user(request):
+        cdxuser = user.User.load(app.model_redis, "defaultuser")
+        if cdxuser is None:
+            cdxuser = make_default_user(app)
+        return cdxuser
+    def write_plot_file(username, codedata):
+        fpath = 'webplot.py'
+        with open(fpath, "w+") as f:
+            f.write(codedata)
+    app.current_user = current_user
+    app.write_plot_file = write_plot_file
+
+http_server = None
+
+def start_app():
+    global http_server
+    http_server = WSGIServer(('', 5006), app,
+                             handler_class=WebSocketHandler,
+                             )
+    http_server.serve_forever()
+
     
-def shutdown_app():
-    print 'shutting down app!'
-    app.proxy.kill = True
-    app.proxyclient.kill = True
 
+#database
 
+#logging
diff --git a/cdx/test/bbmodel_test.py b/cdx/test/bbmodel_test.py
index 9de1b3a..f817b2e 100644
--- a/cdx/test/bbmodel_test.py
+++ b/cdx/test/bbmodel_test.py
@@ -9,26 +9,25 @@ import cdx.redisutils as redisutils
 from cdx.app import app
 import cdxlib.bbmodel as bbmodel
 import cdx.start as start
+import cdx.models.docs as docs
+import requests
+import redis
 
-
-class TestBBModel(unittest.TestCase):
+class TestBBModel(test_utils.CDXServerTestCase):
     def setUp(self):
-        start.prepare_app(rport=6899)
-        self.servert = gevent.spawn(start.start_app)
+        super(TestBBModel, self).setUp()
+        doc2 = docs.new_doc(app, "defaultdoc2",
+                            'main', rw_users=["defaultuser"],
+                            apikey='nokey')
         self.client = bbmodel.ContinuumModelsClient(
-            "mydoc", "http://localhost:5006/bb/", app.ph)
+            "defaultdoc", "http://localhost:5006/cdx/bb/",
+            'nokey', app.ph
+            )
         self.client2 = bbmodel.ContinuumModelsClient(
-            "mydoc2", "http://localhost:5006/bb/", app.ph)
-        self.redisproc = redisutils.RedisProcess(6899, '/tmp', save=False)
-        time.sleep(0.1)
-        
-    def tearDown(self):
-        start.shutdown_app()
-        self.servert.kill()
-        self.redisproc.close()        
-        time.sleep(1.0)
+            "defaultdoc2", "http://localhost:5006/cdx/bb/", "nokey",
+            app.ph,
+            )
 
-        
     def test_create(self):
         test_utils.wait_until(lambda : start.http_server.started)
         client = self.client
diff --git a/cdx/test/test_utils.py b/cdx/test/test_utils.py
index f0bcb80..0241804 100644
--- a/cdx/test/test_utils.py
+++ b/cdx/test/test_utils.py
@@ -1,12 +1,49 @@
+import unittest
+import gevent
+import cdx.redisutils as redisutils
+from cdx.app import app
+import cdxlib.bbmodel as bbmodel
+import cdx.start as start
+import redis
 import time
 from gevent_zeromq import zmq
+import redis
+from requests.exceptions import ConnectionError
+import requests
+
+def wait_flask():
+    def helper():
+        try:
+            return requests.get('http://localhost:5006/cdx/userinfo/')
+        except ConnectionError as e:
+            return False
+    return wait_until(helper)
+
+def wait_redis_gone(port):
+    def helper():
+        client = redis.Redis(port=port)
+        try:
+            client.ping()
+            return False
+        except redis.ConnectionError:
+            return True
+    return wait_until(helper)
+
+def wait_redis_start(port):
+    def helper():
+        client = redis.Redis(port=port)
+        try:
+            return client.ping()
+        except redis.ConnectionError:
+            pass
+    return wait_until(helper)
 
 def wait_until(func, timeout=1.0, interval=0.01):
     st = time.time()
     while True:
         if func():
             return True
-        if (time.time() - st) > interval:
+        if (time.time() - st) > timeout:
             return False
         time.sleep(interval)
 
@@ -19,3 +56,19 @@ def recv_timeout(socket, timeout):
 	else:
 		return None
 	
+class CDXServerTestCase(unittest.TestCase):
+    def setUp(self):
+        start.prepare_app(rport=6899)
+        start.prepare_local()
+        self.servert = gevent.spawn(start.start_app)        
+        self.redisproc = redisutils.RedisProcess(6899, '/tmp', save=False)
+        wait_redis_start(6899)
+        redis.Redis(port=6899).flushall()
+        start.make_default_user(app)
+        wait_flask()
+        
+    def tearDown(self):
+        self.servert.kill()
+        self.redisproc.close()
+        wait_redis_gone(6899)
+    
diff --git a/cdx/test/usermodel_test.py b/cdx/test/usermodel_test.py
index 4035302..db21e21 100644
--- a/cdx/test/usermodel_test.py
+++ b/cdx/test/usermodel_test.py
@@ -1,18 +1,11 @@
 from cdx.app import app
-from flask import (
-	render_template, request, current_app,
-	send_from_directory, make_response, session)
 import time
 import unittest
 import mock
-import websocket
 import gevent
-
-import arrayserver.server.tests.test_utils as test_utils
-import arrayserver.server.redisutils as redisutils
+import test_utils
 import redis
-
-import cdx.controllers.maincontroller as maincontroller
+import cdx.redisutils as redisutils
 import cdx.bbmodel as bbmodel
 import cdx.models.user as user
 import cdx.models as models
@@ -20,14 +13,10 @@ import requests
 
 frontaddr = "tcp://127.0.0.1:6000"
 
-class TestUser(unittest.TestCase):
+class TestUser(test_utils.CDXServerTestCase):
     def setUp(self):
-        self.redisproc = redisutils.RedisProcess(6379, '/tmp', save=False)
-        time.sleep(0.1)
-        self.client = redis.Redis(db=3)
-        
-    def tearDown(self):
-        self.redisproc.close()
+        super(TestUser, self).setUp()
+        self.client = app.model_redis
 
     def test_cant_create_twice(self):
         model = user.new_user(self.client, 'test@test.com', 'mypassword',
@@ -40,80 +29,80 @@ class TestUser(unittest.TestCase):
                           user.auth_user,
                           self.client, 'test@test.com', 'mypassword')
         model = user.new_user(self.client, 'test@test.com', 'mypassword')
-        assert model.email == 'test@test.com'
+        assert model.username == 'test@test.com'
         model = user.auth_user(self.client, 'test@test.com', 'mypassword')
         self.assertRaises(models.UnauthorizedException, user.auth_user,
                           self.client, 'test@test.com', 'wrongpassword')
         
             
-class TestUserModelWeb(unittest.TestCase):
-    def setUp(self):
-        maincontroller.prepare_app(frontaddr, timeout=0.1)        
-        self.servert = gevent.spawn(maincontroller.start_app)
-        self.redisproc = redisutils.RedisProcess(6379, '/tmp', save=False)
-        time.sleep(1.0)
+# class TestUserModelWeb(unittest.TestCase):
+#     def setUp(self):
+#         maincontroller.prepare_app(frontaddr, timeout=0.1)        
+#         self.servert = gevent.spawn(maincontroller.start_app)
+#         self.redisproc = redisutils.RedisProcess(6379, '/tmp', save=False)
+#         time.sleep(1.0)
         
-    def tearDown(self):
-        maincontroller.shutdown_app()
-        self.servert.kill()
-        self.redisproc.close()        
-        time.sleep(1.0)
+#     def tearDown(self):
+#         maincontroller.shutdown_app()
+#         self.servert.kill()
+#         self.redisproc.close()        
+#         time.sleep(1.0)
         
-    def test_invalid_login(self):
-        s = requests.session()
-        response = s.post('http://localhost:5000/login',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        #invalid login
-        assert response.status_code == 401
-        assert s.get('http://localhost:5000/authtest').content == 'WRONG'
+#     def test_invalid_login(self):
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/login',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         #invalid login
+#         assert response.status_code == 401
+#         assert s.get('http://localhost:5000/authtest').content == 'WRONG'
 
-    def test_incorrect_login(self):
-        s = requests.session()
-        response = s.post('http://localhost:5000/register',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        assert response.status_code != 401
-        s = requests.session()        
-        response = s.post('http://localhost:5000/login',
-                          data={'email' : 'test@test.com',
-                                'password' : 'wrong'})
-        #invalid login
-        assert response.status_code == 401
-        assert s.get('http://localhost:5000/authtest').content == 'WRONG'
-    def test_duplicate_registration(self):
-        s = requests.session()
-        response = s.post('http://localhost:5000/register',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        assert response.status_code != 401
-        s = requests.session()        
-        response = s.post('http://localhost:5000/register',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        #invalid login
-        assert response.status_code == 401
-        assert s.get('http://localhost:5000/authtest').content == 'WRONG'
+#     def test_incorrect_login(self):
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/register',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         assert response.status_code != 401
+#         s = requests.session()        
+#         response = s.post('http://localhost:5000/login',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'wrong'})
+#         #invalid login
+#         assert response.status_code == 401
+#         assert s.get('http://localhost:5000/authtest').content == 'WRONG'
+#     def test_duplicate_registration(self):
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/register',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         assert response.status_code != 401
+#         s = requests.session()        
+#         response = s.post('http://localhost:5000/register',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         #invalid login
+#         assert response.status_code == 401
+#         assert s.get('http://localhost:5000/authtest').content == 'WRONG'
 
-    def test_correct_login(self):
-        s = requests.session()
-        response = s.post('http://localhost:5000/register',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        assert response.status_code != 401
-        assert s.get('http://localhost:5000/authtest').content == 'test@test.com'
-        s = requests.session()
-        response = s.post('http://localhost:5000/login',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        assert s.get('http://localhost:5000/authtest').content == 'test@test.com'        
-    def test_logout(self):
-        s = requests.session()
-        response = s.post('http://localhost:5000/register',
-                          data={'email' : 'test@test.com',
-                                'password' : 'mypassword'})
-        assert response.status_code != 401
-        assert s.get('http://localhost:5000/authtest').content == 'test@test.com'
-        s.get('http://localhost:5000/logout')
-        s.get('http://localhost:5000/logout')        
-        assert s.get('http://localhost:5000/authtest').content == 'WRONG'
+#     def test_correct_login(self):
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/register',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         assert response.status_code != 401
+#         assert s.get('http://localhost:5000/authtest').content == 'test@test.com'
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/login',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         assert s.get('http://localhost:5000/authtest').content == 'test@test.com'        
+#     def test_logout(self):
+#         s = requests.session()
+#         response = s.post('http://localhost:5000/register',
+#                           data={'email' : 'test@test.com',
+#                                 'password' : 'mypassword'})
+#         assert response.status_code != 401
+#         assert s.get('http://localhost:5000/authtest').content == 'test@test.com'
+#         s.get('http://localhost:5000/logout')
+#         s.get('http://localhost:5000/logout')        
+#         assert s.get('http://localhost:5000/authtest').content == 'WRONG'
diff --git a/cdx/test/wsmanager_test.py b/cdx/test/wsmanager_test.py
index f178470..c6e828d 100644
--- a/cdx/test/wsmanager_test.py
+++ b/cdx/test/wsmanager_test.py
@@ -5,10 +5,11 @@ import websocket
 import gevent
 
 import cdx.wsmanager as wsmanager
-import arrayserver.server.tests.test_utils as test_utils
+import test_utils
 from cdx.app import app
-import cdx.controllers.maincontroller as maincontroller
-
+from cdx import start
+import cdx.models.docs as docs
+import test_utils
 
 class WSmanagerTestCase(unittest.TestCase):
     def test_some_topics(self):
@@ -25,32 +26,26 @@ class WSmanagerTestCase(unittest.TestCase):
         assert s2.send.call_count == 2
         assert s1.send.call_count == 1
         
-frontaddr = "tcp://127.0.0.1:6000"
-ws_address = "ws://localhost:5000/sub"
-class TestSubscribeWebSocket(unittest.TestCase):
+ws_address = "ws://localhost:5006/cdx/sub"
+class TestSubscribeWebSocket(test_utils.CDXServerTestCase):
     def setUp(self):
-        maincontroller.prepare_app(frontaddr)        
-        self.servert = gevent.spawn(maincontroller.start_app)
-
-    def tearDown(self):
-        time.sleep(1.0)
-        maincontroller.shutdown_app()
-        self.servert.kill()
-        
+        super(TestSubscribeWebSocket, self).setUp()
+        doc2 = docs.new_doc(app, "defaultdoc2",
+                            'main', rw_users=["defaultuser"],
+                            apikey='nokey')
     def test_basic_subscribe(self):
-        ph = maincontroller.app.ph
-        test_utils.wait_until(lambda : maincontroller.http_server.started)
+        ph = start.app.ph
         sock = websocket.WebSocket()
-        connect(sock, ws_address, 'mytopic')
-        app.wsmanager.send('mytopic', 'hello!')
+        connect(sock, ws_address, 'defaultdoc', 'nokey')
+        app.wsmanager.send('defaultdoc', 'hello!')
         msg = sock.recv()
         assert msg == 'hello!'
         sock2 = websocket.WebSocket()
-        connect(sock2, ws_address, 'mytopic')
+        connect(sock2, ws_address, 'defaultdoc', 'nokey')
         sock3 = websocket.WebSocket()
-        connect(sock3, ws_address, 'anothertopic')
-        app.wsmanager.send('mytopic', 'hello2!')        
-        app.wsmanager.send('anothertopic', 'hello3!')
+        connect(sock3, ws_address, 'defaultdoc2', 'nokey')
+        app.wsmanager.send('defaultdoc', 'hello2!')        
+        app.wsmanager.send('defaultdoc2', 'hello3!')
         msg = sock.recv()
         assert msg == 'hello2!'
         msg = sock2.recv()
@@ -58,12 +53,14 @@ class TestSubscribeWebSocket(unittest.TestCase):
         msg = sock3.recv()
         assert msg == 'hello3!'
         
-def connect(sock, addr, topic):
-    ph = maincontroller.app.ph    
+def connect(sock, addr, topic, auth):
+    ph = start.app.ph
     sock.io_sock.settimeout(1.0)
     sock.connect(addr)
     msgobj = dict(msgtype='subscribe',
-                  topic=topic)
+                  topic=topic,
+                  auth=auth
+                  )
     sock.send(ph.serialize_msg(msgobj))
     msg = sock.recv()
     msgobj = ph.deserialize_msg(msg)
diff --git a/cdx/views/backbone.py b/cdx/views/backbone.py
index ad24ea9..548501e 100644
--- a/cdx/views/backbone.py
+++ b/cdx/views/backbone.py
@@ -96,11 +96,9 @@ def put(docid, typename, id):
 @app.route("/cdx/bb/<docid>/<typename>/", methods=['GET'])
 @app.route("/cdx/bb/<docid>/<typename>/<id>", methods=['GET'])
 def get(docid, typename=None, id=None):
+    #not distinguishing between read/write yet
     if not convenience.can_write_from_request(docid, request, app):
-        return app.ph.serialize_web(
-            {'msgtype' : 'error',
-             'msg' : 'unauthorized'}
-            )
+        return app.ph.serialize_web(None)
     if typename is not None and id is not None:
         model = current_app.collections.get(typename, id)
         if model is not None and docid in model.get('docs'):
diff --git a/cdx/views/socket.py b/cdx/views/socket.py
index aa3aab1..49628e5 100644
--- a/cdx/views/socket.py
+++ b/cdx/views/socket.py
@@ -18,7 +18,9 @@ log = logging.getLogger(__name__)
 @app.route('/cdx/sub')
 def sub():
     def auth(auth, topic):
-        return mconv.can_write_doc_api(topic, auth, current_app)
+        status = mconv.can_write_doc_api(topic, auth, current_app)
+        print "AUTH", status
+        return status
     if request.environ.get('wsgi.websocket'):
         ws = request.environ['wsgi.websocket']
         wsmanager.run_socket(
diff --git a/cdx/wsmanager.py b/cdx/wsmanager.py
index 1c1fd69..085adbf 100644
--- a/cdx/wsmanager.py
+++ b/cdx/wsmanager.py
@@ -78,6 +78,7 @@ def run_socket(socket, manager, auth_function,
     log.debug("CLIENTID %s", clientid)     
     while True:
         msg = socket.receive()
+        print msg
         if msg is None:
             manager.remove_socket(clientid)
             manager.remove_clientid(clientid)
diff --git a/startlocal.py b/startlocal.py
index 4455bd7..70ead34 100644
--- a/startlocal.py
+++ b/startlocal.py
@@ -9,39 +9,8 @@ import uuid
 import os
 import logging
 start.prepare_app()
-app.debug = True
-
-#monkeypatching
-def current_user(request):
-    cdxuser = user.User.load(app.model_redis, "defaultuser")
-    if cdxuser is None:
-        docid = str(uuid.uuid4())
-        doc = docs.new_doc(app, docid, 'main', ["defaultuser"])
-        cdxuser = user.new_user(
-            app.model_redis,
-            "defaultuser",
-            str(uuid.uuid4()),
-            docs=[doc.docid])
-    return cdxuser
-
-def write_plot_file(username, codedata):
-    fpath = 'webplot.py'
-    with open(fpath, "w+") as f:
-        f.write(codedata)
-        
-app.current_user = current_user
-app.write_plot_file = write_plot_file
-
-#database
-
-#logging
-
-def start_app():
-    http_server = WSGIServer(('', 5006), app,
-                             handler_class=WebSocketHandler,
-                             )
-    http_server.serve_forever()
+start.prepare_local()
 
 if __name__ == "__main__":
-    start_app()
+    start.start_app()
 
diff --git a/startlocaldebug.py b/startlocaldebug.py
index a02fb50..2e5e12c 100644
--- a/startlocaldebug.py
+++ b/startlocaldebug.py
@@ -4,4 +4,4 @@ if __name__ == "__main__":
     import werkzeug.serving
     @werkzeug.serving.run_with_reloader
     def helper ():
-        startlocal.start_app()
+        start.start_app()
